\documentclass[../../../../thesis]{subfiles}

\IfEq{\jobname}{\detokenize{thesis}}{}{%
    \setcounterref{chapter}{chap:design}
}

\IfEq{\jobname}{\detokenize{thesis}}{}{%
    \StrBehind{\getrefnumber{sec:module-image-loader}}{.}[\tempsectioncounter]
    \setcounter{section}{\tempsectioncounter}
    \addtocounter{section}{-1}
}

\IfEq{\jobname}{\detokenize{thesis}}{}{%
    \StrBehind{\getrefnumber{tab:example-archive-entries}}{.}[\temptablecounter]
    \setcounter{table}{\temptablecounter}
    \addtocounter{table}{-1}
}


\begin{document}

\section{Module Image Loader}\label{sec:module-image-loader}

Module Image Loader chịu trách nhiệm trích xuất và lưu đệm (cache) tệp ảnh.
Module này gồm hai phần như sau:


%----------------------------------------------------------------------------------------
%	4.4.1: Image Extractor
%----------------------------------------------------------------------------------------

\subsection{Image Extractor}\label{sec:image-extractor}

Đây thực chất là một lớp đóng gói quanh \texttt{ComicParser}. Bản thân chức năng
trích xuất được thực hiện trong \texttt{ComicParser} (qua các đối tượng
\texttt{ArchiveParser}), tuy nhiên Image Extractor thực hiện một số tối ưu giúp
việc hiển thị ảnh nhanh chóng hơn.

Ở các mục trước, ta đã tệp lẻ trang truyện không được lưu theo thứ tự đọc. Do
đó, cần mục lục tệp nén để có thể nhảy cóc đến trang truyện theo yêu cầu. Tuy
nhiên, việc tải ảnh còn có thể tối ưu hơn nữa. Ta xét ví dụ trong
\autoref{tab:example-archive-entries}:

\begin{table}[H]
    \centering
    \caption{Danh sách các tệp ảnh trong một tệp truyện nén}
    \label{tab:example-archive-entries}
    \begin{tabular}{l l l}
        \toprule
        Thứ tự trong tệp nén & Tên tệp ảnh & Dung lượng \\
        \midrule
        1 & \texttt{7.jpg} & 100KB \\
        2 & \texttt{6.jpg} & 100KB \\
        3 & \texttt{8.jpg} & 100KB \\
        4 & \texttt{1.jpg} & 100KB \\
        5 & \texttt{3.jpg} & 100KB \\
        6 & \texttt{4.jpg} & 100KB \\
        7 & \texttt{2.jpg} & 100KB \\
        8 & \texttt{5.jpg} & 100KB \\
        \bottomrule
    \end{tabular}
\end{table}

Hiển nhiên, thứ tự ảnh cần xem là từ tệp \texttt{1.jpg} đến tệp
\texttt{8.jpg}. Ta xem xét và cải tiến các chiến lược tải ảnh qua các
tiểu mục tiếp theo.

\subsubsection{Tải theo yêu cầu}

Ảnh được tải theo đúng yêu cầu ngay lúc đó. Quá trình đọc tệp tin như sau:

\begin{itemize}
    \item
        Đọc \texttt{1.jpg}: 100KB (bản thân ảnh) + 300KB (do trước khi đọc được
        \texttt{1.jpg} cần đi qua 3 ảnh \texttt{7.jpg}, \texttt{6.jpg},
        \texttt{8.jpg})
    \item
        Đọc \texttt{2.jpg}: 100KB + 600KB
    \item
        \ldots{}
\end{itemize}

Hai điểm yếu của phương pháp này là:

\begin{itemize}
    \item Tốn IO: Đọc 4500KB (như đã giải thích ở \autoref{sec:cbz}).
    \item Inter-process communication overhead: 8 luồng nhập được tạo ra, tức 8
        lần liên hệ với Content Provider (đã giải thích ở \autoref{sec:saf}).
\end{itemize}

Nguyên nhân của hai điểm yếu trên là do không dùng lại luồng nhập (mỗi
\texttt{InputStream} chỉ đọc một ảnh). Chú ý rằng ở đây không có điểm yếu về tốn
CPU để giải nén, do đã khắc phục trong \texttt{ComicParser}. Phương án tiếp theo
cần xử lí được điểm yếu này.

\subsubsection{Tối thiểu hóa số luồng đọc}

Để giảm số luồng đọc, ta cần mở sẵn một vài luồng đọc, và phân mỗi trang truyện
cho một luồng đọc cụ thể. Để tối thiểu hóa số luồng đọc, ta cần dùng thêm thuật
toán \emph{chuỗi con tăng dài nhất} (longest increasing subsequence). Thuật toán
cuối cùng thể hiện bằng mã giả như sau:

\begin{verbatim}
def minStream(pages):
    stream_count = 0
    map_idx_to_stream = []    # Từ điển ánh xạ số trang - số luồng

    while len(pages) != 0:
        # Dây trang tiến lên
        lis = longest_increasing_subsequence(pages)

        for page in lis:
            pages.remove_at(page)    # Bỏ trang trong dây khỏi danh sách
            map_idx_to_stream[page] = stream_count    # Gán số luồng hiện tại

        stream_count += 1

    return map_idx_to_stream
\end{verbatim}

Thuật toán nhận vào một mảng \texttt{pages} là \emph{thứ tự trong tệp nén} của
từng trang truyện. Thuật toán trả về một từ điển như sau:

\begin{itemize}
    \item
        Khóa: trang truyện số (bắt đầu từ trang 1)
    \item
        Giá trị: số luồng
\end{itemize}

Ta nhận thấy thuật toán hiển nhiên cho (xấp xỉ) số luồng ít nhất có thể, vì mỗi
lần chia trang cho các luồng, ta chọn một bộ trang tăng dần dài nhất lúc đó.

Áp dụng vào ví dụ đang dùng, ta có:

\begin{itemize}
    \item
        Luồng 0: đọc trang 1, 3, 4, 5
    \item
        Luồng 1: đọc trang 7, 8
    \item
        Luồng 2: đọc trang 6
    \item
        Luồng 3: đọc trang 2
\end{itemize}

Vậy để đọc hết truyện, cần đọc 2000KB, và 4 lần tạo mới luồng nhập, khá tốt so
với phương pháp đầu. Cũng cần nói thêm rằng thuật toán này là kiểu \emph{tham
lam} (greedy), không phải thuật toán tối ưu nhất.

Tới đây chỉ cần một số chỉnh sửa nhỏ: Giới hạn số luồng nhập. Trường hợp xấu
nhất là thứ tự trong tệp ZIP ngược với thứ tự đọc, do đó có nhiều luồng mà mỗi
luồng chỉ để đọc một trang truyện. yacv tránh điều này bằng cách giới hạn chỉ có
4 luồng nhập cùng lúc. Những trang không ở trong phạm vi của các luồng này quay
về cách đọc nhảy cóc thông thường, không dùng lại luồng nhập chờ sẵn.


%----------------------------------------------------------------------------------------
%	4.4.2: Image Cache
%----------------------------------------------------------------------------------------

\subsection{Image Cache}\label{sec:image-cache}

Bản thân Image Cache \emph{không} phải là một đoạn mã, đối tượng, mà chỉ là một
thư mục. yacv có 2 loại/thư mục cache, cho hai trường hợp hiển thị:

\begin{itemize}
    \item
        Cache ảnh bìa
    \item
        Cache trang truyện
\end{itemize}

Lý do cần đến hai bộ cache khác nhau là vì dung lượng lớn của truyện. Các thư
viện cache ảnh chọn mốc 100-200MB cho thư mục cache ảnh, đồng thời dùng cố định
phương pháp thay thế LRU (nếu cache đầy sẽ xóa ảnh lâu nhất không được dùng).
Khi đọc một bộ truyện dung lượng lớn hơn mốc này, toàn bộ ảnh trong cache sẽ sớm
bị thay thế bởi ảnh của trang truyện. Sau khi đọc, quay về các màn hình, ảnh bìa
dùng để hiển thị trong hai màn hình duyệt truyện bị mất, gây suy giảm trải
nghiệm người dùng. Do đó, cần phải tách hai thư mục cache này ra để tránh ảnh
hưởng đến cache trang bìa.

\subsubsection{Cache trang truyện}

Khác với cache trang truyện, cache trang bìa \emph{không} có liên quan tới Image
Loader. Thực ra ảnh bìa thì cũng được trích xuất bởi \texttt{ComicParser}, tuy
nhiên với mỗi tệp truyện chỉ cần trích ra một ảnh bìa, do đó không cần cơ chế
tái sử dụng luồng đọc phức tạp của Image Loader.

Cache trang bìa lại gồm 2 thư mục cache:

\begin{enumerate}
    \item
        Cache ảnh hiển thị thực tế

        Cache ảnh được hiển thị bởi \texttt{ImageView}. Ảnh này là ảnh bìa đã
        được cắt (xem phần thiết kế màn hình duyệt truyện) và được thu phóng về
        chính xác kích cỡ khung nhìn. Dung lượng cache là 100MB.

        Cùng một bìa có hai kiểu hiển thị

        Thư mục cache này được quản lí bởi thư viện hiển thị ảnh. Thư viện đó
        nhận luồng đọc ảnh (từ \texttt{ComicParser}), ghi vào thư mục cache này,
        và xóa ảnh để giải phóng dung lượng khi cần.
    \item
        Cache ảnh bìa thu nhỏ

        Cache ảnh bìa thu nhỏ, khoảng 50KB mỗi ảnh, chưa bị cắt. Dung lượng
        cache là 10MB.
\end{enumerate}

Lí do riêng phần bìa cần hai thư mục cache là vì cache ảnh hiển thị thực tế,
giống với cache trang truyện, có thể bị xóa bất cứ lúc nào. Do đó cần có một
cache rất nhỏ gọn, nằm ở thư mục riêng mà Android không xóa được, chứa ảnh bìa
chất lượng thấp, để khi ảnh bìa bị xóa vẫn có một bản bìa nhỏ để hiển thị trong
khi chờ ảnh bìa chất lượng cao, có cắt cúp phù hợp được sinh lại.

Trong \autoref{fig:scan_new_sequence}, có một lớp \texttt{ImageCache} nhận
\texttt{InputStream} của ảnh bìa và cache ảnh, đó chính là lớp quản lí và sinh
ảnh bìa thu nhỏ.


\end{document}
